// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'backbone', 'util', 'models/appState', 'models/classifier', 'models/responder', 'handlebars'], function(_, Backbone, Util, AppState, Classifier, Responder) {
    var IndexView, _ref;
    return IndexView = (function(_super) {
      __extends(IndexView, _super);

      function IndexView() {
        this.requestStatus = __bind(this.requestStatus, this);
        this.resolver = __bind(this.resolver, this);
        this.disambiguateResults = __bind(this.disambiguateResults, this);
        this.disambiguate = __bind(this.disambiguate, this);
        this.show = __bind(this.show, this);
        _ref = IndexView.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      IndexView.prototype.events = {
        'keyup #main-input': 'keyup',
        'webkitspeechchange #main-input': 'ask'
      };

      IndexView.prototype.initialize = function() {
        this.board = $('#board');
        this.loader = $('#loader');
        this.disambiguator = 'http://casper.stremor-nli.appspot.com/disambiguate';
        this.templates = {
          bubblein: Handlebars.compile($('#bubblein-template').html()),
          bubbleout: Handlebars.compile($('#bubbleout-template').html()),
          simulate: Handlebars.compile($('#simulate-template').html()),
          shopping: Handlebars.compile($('#shopping-template').html()),
          images: Handlebars.compile($('#images-template').html()),
          list: Handlebars.compile($('#list-template').html()),
          web: Handlebars.compile($('#web-template').html())
        };
        AppState.on('change:mainContext', this.resolver);
        return AppState.on('change:requestStatus', this.requestStatus);
      };

      IndexView.prototype.render = function(options) {
        var init;
        if (this.board.is(':empty')) {
          init = $('#init');
          init.fadeIn('slow');
          return setTimeout((function() {
            return init.fadeOut('slow');
          }), 1000);
        }
      };

      IndexView.prototype.show = function(data) {
        this.board.append(this.templates.bubbleout(data)).scrollTop(this.board.height());
        return this.loader.hide();
      };

      IndexView.prototype.ask = function(e) {
        var classifier, dis, input, text;
        input = $(e);
        text = input.val();
        input.val('');
        this.board.append(this.templates.bubblein(text));
        if (AppState.inProgress === true) {
          console.log('should disambiguate');
          return dis = new Disambiguator({
            text: text
          });
        } else {
          classifier = new Classifier();
          return classifier.fetch({
            data: {
              query: text
            }
          });
        }
      };

      IndexView.prototype.keyup = function(e) {
        var history, target, value;
        value = $(e.target).val();
        target = $(e.target);
        history = AppState.get('history');
        switch (e.which) {
          case 13:
            if (value) {
              this.ask(target);
            }
            return AppState.set('pos', history.length);
          case 38:
            if (pos > 0) {
              pos -= 1;
            }
            return target.val(history[pos]);
          case 40:
            if (pos < history.length) {
              pos += 1;
            }
            return target.val(history[pos]);
        }
      };

      IndexView.prototype.disambiguate = function(payload) {
        var context, data, endpoint, field, text, type;
        if (AppState.get('inProgress') === true) {
          endpoint = this.disambiguator + '/active';
          context = AppState.get('responderContext');
          field = context.field;
          type = AppState.responderContext.type;
          text = payload;
          data = {
            text: text,
            types: [type]
          };
          console.log('disambiguate user response', data);
        } else {
          console.log('disambiguate rez response');
          endpoint = this.disambiguator + '/passive';
          context = AppState.get('mainContext');
          field = payload.field;
          type = payload.type;
          text = context.get('payload')[field];
          data = {
            text: text,
            types: [type]
          };
        }
        return Util.requestHelper(endpoint, 'POST', data, this.disambiguateResults);
      };

      IndexView.prototype.disambiguateResults = function(response) {
        var context, datetime, payload;
        if (response != null) {
          if (((response.date != null) && typeof response.date === 'object') || ((response.time != null) && typeof response.time === 'object')) {
            datetime = Util.buildDatetime(response.date, response.time);
            response[type] = datetime[type];
            console.log('done handler', response);
          }
          context = AppState.get('mainContext');
          payload = context.get('payload');
          payload[field] = response[type];
          context.set('payload', payload);
          return AppState.set('mainContext', context);
        }
      };

      IndexView.prototype.resolver = function(model, response, opts) {
        /*
        			here is where we need to make checks of whether to pass along data
        			to 'REZ' or resolve with the disambiguator
        */

        var datetime, dis, payload, responder;
        if (response.status != null) {
          switch (response.status.toLowerCase()) {
            case 'disambiguate':
              console.log('resolver disambiguate', response);
              dis = new Disambiguator();
              return dis.save(response);
            case 'in progress':
              console.log('resolver progress', response);
              this.AppState.set({
                inProgress: true,
                responderContext: response
              });
              return this.show(response);
            case 'complete':
            case 'completed':
              console.log('resolver complete', response);
              AppState.set({
                inProgress: false,
                responderContext: {}
              });
              return this.show(response);
          }
        } else {
          console.log('resolver response without status', response, AppState.get('mainContext'));
          payload = response.payload;
          if (payload != null) {
            if (((payload.start_date != null) && typeof payload.start_date === 'object') || ((payload.start_time != null) && typeof payload.start_time === 'object')) {
              datetime = this.buildDatetime(payload.start_date, payload.start_time);
              if (payload.start_date != null) {
                payload.start_date = datetime.date;
              }
              if (payload.start_time != null) {
                payload.start_time = datetime.time;
              }
            }
            if (((payload.end_date != null) && typeof payload.end_date === 'object') || ((payload.end_time != null) && typeof payload.end_time === 'object')) {
              datetime = this.buildDatetime(payload.end_date, payload.end_time);
              if (payload.end_date != null) {
                payload.end_date = datetime.date;
              }
              if (payload.end_time != null) {
                payload.end_time = datetime.time;
              }
            }
          }
          AppState.set('mainContext', response);
          responder = new Responder();
          return responder.save(response);
        }
      };

      IndexView.prototype.requestStatus = function(model, response, opts) {
        if (response === 'beforeSend') {
          return this.loader.show();
        } else {
          return this.loader.hide();
        }
      };

      return IndexView;

    })(Backbone.View);
  });

}).call(this);
